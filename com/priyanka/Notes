[12-5-25]

Java Collections: LinkedList
----------------------------
The LinkedList class in java is a part of the Collection framework and implements the List interface, unlike
an ArrayList, which uses a dynamic array to store the elements, a LinkedList stores its elements as nodes in
a doubly linked list. This provides different performance characteristics and usage scenarios compared to ArrayList.


A LinkedLIst is a linear data structure where each element is a separate object called a node. Each node
contains two parts:
Data : the value stored in the node
Pointers : two pointers, one pointing to the next node(next) and the other pointing to the previous node(previous)

Performance Consideration : LinkedList has different performance characteristics compared to ArrayList:
->insertion and deletion : LinkedList is better for frequent insertion and deletion in the middle of the
list because it because it does not require shifting of elements, as in ArrayList.
->random access : LinkedList has slower random access(get(int index)) compared to ArrayList because it has to
traverse the list from the beginning t reach the desired index.
->memory overhead : LinkedList requires more memory than ArrayList because each node in a linked list requires
extra memory to store reference to the next and previous nodes.


Vector
---------------------------
A vector in java is a part of the java.util package and is one of thr legacy classes in java that implements the
List interface.
It was introduced in JDK 1.0 before collection framework and is synchronized, making it thread safe.
Now it is a part of collection framework.
However, due to its synchronization overhead, it's generally recommended to use other modern alternatives like
ArrayList in single-threaded scenarios. Despite this, Vector is still useful in certain situations, particularly in
multithreaded environments where thread safety is a concern.

Key features of vector :

->dynamic array : like ArrayList, Vector is a dynamic array that grows automatically when more elements are added than
its current capacity.
->synchronized : All the method in Vector are synchronized, which makes it thread safe. This means multiple threads can
work on a Vector without the risk of corrupting the data. However this can introduced performance overhead in single-threaded environments.
->legacy class : Vector was part of Java's original release and is considered a legacy class. It's generally recommended to use ArrayList in
single-threaded environments due to proper considerations.
->resizing mechanism : when the current capacity of the vector is exceeded, it doubles its size by default(or increases by a specific capacity
increment if provided).
->random access : similar to arrays and ArrayList, Vector allows random access to elements, making it efficient for accessing elements using an
index.

Constructors of Vector :

->Vector() : creates a vector with an initial capacity of 10.
->Vector(int initialCapacity) : creates a vector with a specified initial capacity.
->Vector(int initialCapacity, int capacityIncrement) : creates a vector with an initial capacity and capacity increment (how much the vector
should grow when its capacity is exceeded).
->Vector(Collection<?extends E>c) : creates a vector containing the elements of the specified collection.

Methods in Vector :

-> add(E e) : adds an element at the end.
-> add(int index, E element) : inserts an element at the specified index.
-> get(int index) : retrieves the element at the specified index.
-> set(int index, E element) : replaces the element at the specified element.
-> remove(Object o) : removes the first occurrence of the specified element.
-> remove(int index) : removes the element at the specified index.
-> size() : returns the number of elements in the vector.
-> isEmpty() : checks if the vector i empty.
-> contains(Object o) : checks if the vector contains the specified element.
-> clear() : removes all elements from the vector.

Internal implementation of vector :

Internally, Vector uses an array to store its elements. The size of this array grows as needed when more elements are added.
The default behaviour is to double the size of the array when it runs out of space. This resizing operation is a costly onex,
as it requires copying the old elements to the new, larger array.

Synchronization and performance :

Since vector methods are synchronized, it ensures that only one thread can access the vector at a time. This makes it
thread-safe but can introduce performance overhead in single-threaded environments because synchronization adds locking
and unlocking costs.
In modern Java applications, ArrayList is generally preferred over Vector when synchronization isn't required.
For thread-safe collections, the CopyOnWriteArrayList or ConcurrentHashMap from the
java.util.concurrent package is often recommended instead.

Stack
-------------------------------------

Since stack extends vector, it is synchronized, making it thread safe.

LIFO Structure : Stack follows the LIFO principle, where the last element added is the first one to be removed.

Inheritance : Stack is a subclass of Vector, which means it inherits all the features of a dynamic array but is
constrained by stack's LIFO nature.

